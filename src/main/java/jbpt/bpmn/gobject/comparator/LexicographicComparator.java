package jbpt.bpmn.gobject.comparator;

import org.jbpt.hypergraph.abs.IVertex;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LexicographicComparator implements Comparator<IVertex> {
  /**
   * Splits a string into substrings of character or digits ONLY.
   * <p>
   * The strings received are names of GObject instances generated by the bpmn-model-generator. These names have two
   * substrings:
   * <ul>
   *   <li>A substring of characters only -i.e., [a-z]+|[A-Z]+- that specifies the type of flow node the GObject is
   *   -e.g., "s" for StartEvent instances, "e" for EndEvent instances, "t" for Task instances, etc.-.
   *   <li>A substring of digits only -i.e., [0-9]+- used to differentiate flow nodes of the same type in a model
   *   -e.g., "t2" is different from "t1" and so on-.
   * </ul>
   * Therefore, the method will return lists of two strings, one for each substring:
   * <ul>
   *   <li>The substring of characters only.
   *   <li>The substring of digits only.
   * </ul>
   * <p>
   * This method is needed because two comparisons are needed to determine the correct lexicographical order. If we
   * were to compare the names of the GObject instances directly, then we would have the following error: "t59" < "t6".
   * @param str   the string to split
   * @return      the list of substrings the original string was split into.
   */
  private List<String> parse(String str) {
    List<String> output = new ArrayList<>();
    Matcher match = Pattern.compile("[0-9]+|[a-z]+|[A-Z]+").matcher(str);
    while (match.find()) {
      output.add(match.group());
    }
    return output;
  }

  @Override
  public int compare(IVertex a, IVertex b) {
    List<String> tokensA = parse(a.getName());
    List<String> tokensB = parse(b.getName());
    String typeA = tokensA.get(0);
    String typeB = tokensB.get(0);
    int firstComparison = typeA.compareToIgnoreCase(typeB);
    if (firstComparison != 0) return firstComparison;
    else {
      Integer indexA = Integer.parseInt(tokensA.get(1));
      Integer indexB = Integer.parseInt(tokensB.get(1));
      return indexA.compareTo(indexB);
    }
  }
}